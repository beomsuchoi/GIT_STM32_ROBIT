/* USER CODE BEGIN Header */
/**
  *******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  *******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  *******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "adc.h"
#include "dma.h"
#include "i2c.h"
#include "tim.h"
#include "gpio.h"
#include <math.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
int target_speed = 0; // 목표 속도
int speed = 0;
int current_speed;    // 현재 속도
int encoder_value;
int prev_encoder_value = 0;
int count = 0;
int encoder_arr[2];
float speed_error = 0; // 속도 오차
float speed_integral = 0; // 속도 제어 적분 항
float speed_derivative = 0; // 속도 제어 미분 항
float prev_speed_error = 0;
float Kp_speed = 1.5, Ki_speed = 0.1, Kd_speed = 0.05; // 속도 PID 상수
float pid_output;
float motor_value;
float dt = 0.01;     // 시간 간격

int target_rpm = 0;
int current_rpm;
float angle_xz_filtered = 0;
const float alpha = 0.98;

float angle_xz_kalman = 0;
float Q_angle = 0.001;
float Q_gyro = 0.003;
float R_angle = 0.5;
float bias = 0;
float P[2][2] = {{1, 0}, {0, 1}};
float Ax, Ay, Az, Gx, Gy, Gz;
float angle_xz;
float filtered_angle;

float Kp = 7.5;
float Ki = 0;
float Kd = 0;
float integral = 0;
float prev_error = 0;
float prev_derivative = 0;
float motor_pwm;
/* USER CODE END Includes */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void MPU6050_Init(void);
void MPU6050_Read_Accel(void);
void MPU6050_Read_Gyro(void);
float Calculate_XZ_Angle(float Gx, float Gz);
void Update_Angle(void);
void Kalman_Filter(float new_angle, float new_rate);
float calculate_pid(float setpoint, float measured_value);
float calculate_speed_pid(float target_speed, float current_speed);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);

/* USER CODE BEGIN 0 */

/* 속도 PID 제어 함수 */
float calculate_speed_pid(float target_speed, float current_speed) {
    float error = target_speed - current_speed;
    speed_integral += error * dt;
    speed_integral = fmaxf(fminf(speed_integral, INTEGRAL_MAX), INTEGRAL_MIN);

    speed_derivative = (error - prev_speed_error) / dt;
    float output = Kp_speed * error + Ki_speed * speed_integral + Kd_speed * speed_derivative;

    prev_speed_error = error;
    return output;
}

/* 각도 PID 제어 함수 */
float calculate_pid(float setpoint, float measured_value) {
    float error = setpoint - measured_value;
    float non_linear_error = non_linear_response(error);

    integral += non_linear_error * dt;
    integral = fmaxf(fminf(integral, INTEGRAL_MAX), INTEGRAL_MIN);

    float derivative = (non_linear_error - prev_error) / dt;
    float filtered_derivative = 0.7f * derivative + 0.3f * prev_derivative;

    float output = Kp * non_linear_error + Ki * integral + Kd * filtered_derivative;

    prev_error = non_linear_error;
    prev_derivative = filtered_derivative;

    return output;
}

/* USER CODE END 0 */

/* Infinite loop */
int main(void) {
    /* Initialize all configured peripherals */
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_TIM1_Init();
    MX_TIM3_Init();
    MX_TIM6_Init();
    MX_I2C1_Init();
    MX_ADC1_Init();
    MX_TIM8_Init();

    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
    HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
    HAL_TIM_Base_Start_IT(&htim6);

    MPU6050_Init();

    /* USER CODE BEGIN WHILE */
    while (1) {
        MPU6050_Read_Accel();
        MPU6050_Read_Gyro();

        angle_xz = Calculate_XZ_Angle(Gx, Gz);
        Update_Angle();
        Kalman_Filter(angle_xz, Gx);

        filtered_angle = angle_xz_filtered - 3.5;  // 보정값 적용
        encoder_value = TIM3->CNT;

        // 인코더 값을 통해 속도 계산
        current_speed = (encoder_value - prev_encoder_value) / dt;  // 속도 계산 (카운트 차이 / 시간)
        prev_encoder_value = encoder_value;

        // 각도 기반 PID 제어
        float angle_pid_output = calculate_pid(0, filtered_angle);

        // 속도 기반 PID 제어
        float speed_pid_output = calculate_speed_pid(target_speed, current_speed);

        // 최종 PID 출력은 각도와 속도 PID를 결합
        pid_output = angle_pid_output + speed_pid_output;

        // 출력 제한
        pid_output = fmaxf(fminf(pid_output, MAX_MOTOR_OUTPUT), -MAX_MOTOR_OUTPUT);
        motor_value = fabsf(pid_output);

        // 모터 제어
        if (pid_output >= 0) {
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, SET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_9, SET);
        } else {
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, RESET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_9, RESET);
        }

        // 모터 PWM 설정
        TIM1->CCR1 = motor_value;
        TIM1->CCR2 = motor_value;
    }
    /* USER CODE END WHILE */
}

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM6) {
        encoder_arr[count] = encoder_value;
        count++;
        count = count % 2;
    }
}
/* USER CODE END 4 */

/* System Clock Configuration */
void SystemClock_Config(void) {
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    __HAL_RCC_PWR_CLK_ENABLE();
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM = 8;
    RCC_OscInitStruct.PLL.PLLN = 180;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
    RCC_OscInitStruct.PLL.PLLQ = 2;
    RCC_OscInitStruct.PLL.PLLR = 2;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
        Error_Handler();
    }

    if (HAL_PWREx_EnableOverDrive() != HAL_OK) {
        Error_Handler();
    }

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) {
        Error_Handler();
    }
}

/* USER CODE BEGIN 4 */
void Error_Handler(void) {
    __disable_irq();
    while (1) {
    }
}
/* USER CODE END 4 */


#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
